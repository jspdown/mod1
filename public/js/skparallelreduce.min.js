var SKPR=SKPR||{version:"1.0.3"};console.log("Using SKPR "+SKPR.version);SKPR.ParallelReducer=function(a,b,d){if("undefined"===typeof a)throw Error("renderer not specified");this.__renderer=a;this.__checkExtensions();if("undefined"===typeof b)throw Error("res not specified");if(b&b-1)throw Error("res is not a power of 2");this.__res=b;if(b&b-1)throw Error("res is not a power of 2");this.__stopRes=d||1;if(this.__res<=this.__stopRes)throw Error("stopRes must be smaller than res");this.__init()};
SKPR.ParallelReducer.prototype.__checkExtensions=function(){if(!this.__renderer.context.getExtension("OES_texture_float"))throw alert("No support for floating point textures. Extension not available: OES_texture_float"),Error("No support for floating point textures. Extension not available: OES_texture_float");};SKPR.ParallelReducer.prototype.__init=function(){this.__setupRttScene();this.__setupRttRenderTargets();this.__setupRttShaders();this.__pixelByteData=new Uint8Array(4*this.__stopRes*this.__stopRes)};
SKPR.ParallelReducer.prototype.__setupRttScene=function(){this.__rttScene=new THREE.Scene;this.__rttCamera=new THREE.OrthographicCamera(-0.5,0.5,0.5,-0.5,-1E4,1E4);var a,b=1,d=1,f=new THREE.Texture;this.__rttQuadMeshes=[];for(a=this.__res;1<=a;a/=2){var c=new THREE.PlaneGeometry(1,1);c.faceVertexUvs[0][0][0].set(0,1);c.faceVertexUvs[0][0][1].set(0,1-b);c.faceVertexUvs[0][0][2].set(b,1-b);c.faceVertexUvs[0][0][3].set(b,1);c.applyMatrix((new THREE.Matrix4).makeTranslation(0.5,-0.5,0));c.applyMatrix((new THREE.Matrix4).makeScale(d,
d,d));c.applyMatrix((new THREE.Matrix4).makeTranslation(-0.5,0.5,0));c=new THREE.Mesh(c,new THREE.MeshBasicMaterial({map:f}));c.visible=!1;this.__rttScene.add(c);this.__rttQuadMeshes.push(c);b/=2;d/=2}};
SKPR.ParallelReducer.prototype.__setupRttRenderTargets=function(){this.__nearestFloatRgbaParams={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,format:THREE.RGBAFormat,stencilBuffer:!1,depthBuffer:!1,type:THREE.FloatType};this.__rttRenderTarget1=new THREE.WebGLRenderTarget(this.__res,this.__res,this.__nearestFloatRgbaParams);this.__rttRenderTarget1.generateMipmaps=!1;this.__rttRenderTarget2=this.__rttRenderTarget1.clone()};
SKPR.ParallelReducer.prototype.__setupRttShaders=function(){this.__rttMaterials={};this.__rttMaterials.sum=new THREE.ShaderMaterial({uniforms:{uTexture:{type:"t",value:null},uTexelSize:{type:"f",value:0},uHalfTexelSize:{type:"f",value:0},uChannelMask:{type:"v4",value:new THREE.Vector4}},vertexShader:this.__shaders.vert.passUv,fragmentShader:this.__shaders.frag.parallelSum});this.__rttEncodeFloatMaterial=new THREE.ShaderMaterial({uniforms:{uTexture:{type:"t",value:null},uChannelMask:{type:"v4",value:new THREE.Vector4}},
vertexShader:this.__shaders.vert.passUv,fragmentShader:this.__shaders.frag.encodeFloat});this.__channelVectors={r:new THREE.Vector4(1,0,0,0),g:new THREE.Vector4(0,1,0,0),b:new THREE.Vector4(0,0,1,0),a:new THREE.Vector4(0,0,0,1)}};
SKPR.ParallelReducer.prototype.__shaders={vert:{passUv:"varying vec2 vUv;\nvoid main() {\nvUv = vec2(uv.x, uv.y);\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"},frag:{encodeFloat:"uniform sampler2D uTexture;\nuniform vec4 uChannelMask;\nvarying vec2 vUv;\nfloat shift_right(float v, float amt) {\nv = floor(v) + 0.5;\nreturn floor(v / exp2(amt));\n}\nfloat shift_left(float v, float amt) {\nreturn floor(v * exp2(amt) + 0.5);\n}\nfloat mask_last(float v, float bits) {\nreturn mod(v, shift_left(1.0, bits));\n}\nfloat extract_bits(float num, float from, float to) {\nfrom = floor(from + 0.5);\nto = floor(to + 0.5);\nreturn mask_last(shift_right(num, from), to - from);\n}\nvec4 encode_float(float val) {\nif (val == 0.0) {\nreturn vec4(0, 0, 0, 0);\n}\nfloat sign = val > 0.0 ? 0.0 : 1.0;\nval = abs(val);\nfloat exponent = floor(log2(val));\nfloat biased_exponent = exponent + 127.0;\nfloat fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\nfloat t = biased_exponent / 2.0;\nfloat last_bit_of_biased_exponent = fract(t) * 2.0;\nfloat remaining_bits_of_biased_exponent = floor(t);\nfloat byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;\nfloat byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;\nfloat byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;\nfloat byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\nreturn vec4(byte4, byte3, byte2, byte1);\n}\nvoid main() {\nvec4 t = texture2D(uTexture, vUv);\ngl_FragColor = encode_float(dot(t, uChannelMask));\n}",parallelSum:"uniform sampler2D uTexture;\nuniform float uTexelSize;\nuniform float uHalfTexelSize;\nuniform vec4 uChannelMask;\nvarying vec2 vUv;\nvoid main() {\n//read original texture\nvec4 t = texture2D(uTexture, vUv);\n//expand the UVs and then read data from neighbours\n//do dot product with uChannelMask vector to mask out only the channel value needed\nfloat oneMinusHalfTexelSize = 1.0 - uHalfTexelSize;\nvec2 expandedUv = vec2(\n(vUv.x - uHalfTexelSize) * 2.0 + uHalfTexelSize,\n(vUv.y - oneMinusHalfTexelSize) * 2.0 + oneMinusHalfTexelSize\n);\nfloat v1 = dot(texture2D(uTexture, expandedUv), uChannelMask);\nfloat v2 = dot(texture2D(uTexture, expandedUv + vec2(uTexelSize, 0.0)), uChannelMask);\nfloat v3 = dot(texture2D(uTexture, expandedUv + vec2(uTexelSize, -uTexelSize)), uChannelMask);\nfloat v4 = dot(texture2D(uTexture, expandedUv + vec2(0.0, -uTexelSize)), uChannelMask);\n//sum of values\nfloat final = v1 + v2 + v3 + v4;\ngl_FragColor = (vec4(1.0) - uChannelMask) * t + uChannelMask * final;\n}"}};
SKPR.ParallelReducer.prototype.__swapRenderTargets=function(){var a=this.__rttRenderTarget1;this.__rttRenderTarget1=this.__rttRenderTarget2;this.__rttRenderTarget2=a};
SKPR.ParallelReducer.prototype.reduce=function(a,b,d){b=this.__rttMaterials[b];var f=!0,c=1/this.__res,e=1;for(this.__currRes=this.__res;this.__currRes>this.__stopRes;)this.__currRes/=2,this.__swapRenderTargets(),this.__rttQuadMeshes[e].visible=!0,this.__rttQuadMeshes[e].material=b,b.uniforms.uTexture.value=f?a:this.__rttRenderTarget2,b.uniforms.uTexelSize.value=c,b.uniforms.uHalfTexelSize.value=c/2,b.uniforms.uChannelMask.value.copy(this.__channelVectors[d]),this.__renderer.render(this.__rttScene,
this.__rttCamera,this.__rttRenderTarget1,!1),this.__rttQuadMeshes[e].visible=!1,e+=1,f=!1};
SKPR.ParallelReducer.prototype.getPixelFloatData=function(a){this.__swapRenderTargets();this.__rttQuadMeshes[0].visible=!0;this.__rttQuadMeshes[0].material=this.__rttEncodeFloatMaterial;this.__rttEncodeFloatMaterial.uniforms.uTexture.value=this.__rttRenderTarget2;this.__rttEncodeFloatMaterial.uniforms.uChannelMask.value.copy(this.__channelVectors[a]);this.__renderer.render(this.__rttScene,this.__rttCamera,this.__rttRenderTarget1,!1);this.__rttQuadMeshes[0].visible=!1;a=this.__renderer.getContext();
a.bindFramebuffer(a.FRAMEBUFFER,this.__rttRenderTarget1.__webglFramebuffer);a.readPixels(0,this.__res-this.__stopRes,this.__stopRes,this.__stopRes,a.RGBA,a.UNSIGNED_BYTE,this.__pixelByteData);a.bindFramebuffer(a.FRAMEBUFFER,null);return new Float32Array(this.__pixelByteData.buffer)};
